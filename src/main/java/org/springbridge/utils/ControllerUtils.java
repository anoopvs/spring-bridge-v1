 /*
 * Copyright 2020 Anoop V S.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springbridge.utils;

import java.util.Collection;
import java.util.Collections;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;

import javax.annotation.Nullable;
import javax.servlet.DispatcherType;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springbridge.action.ActionErrors;
import org.springbridge.action.ActionMapping;
import org.springbridge.action.ActionMessages;
import org.springbridge.action.ConfigurationException;
import org.springbridge.action.Globals;
import org.springbridge.support.handler.ActionContext;
import org.springframework.context.ApplicationContext;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.util.StringUtils;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.web.servlet.LocaleResolver;
import org.springframework.web.servlet.support.RequestContextUtils;
import org.springframework.web.util.WebUtils;

/**
 * Utility class with static methods shared between various framework classes
 * 
 * @author Anoop V S
 *
 */
public final class ControllerUtils {

	private ControllerUtils() {
	}

	/**
	 * Create a TRANSACTION Token and save it in session.
	 *
	 * @param httpRequest the current request
	 * @return boolean true
	 */
	public static boolean saveToken(final HttpServletRequest httpRequest) {
		// if the request does not have a session, creates one.
		final HttpSession session = httpRequest.getSession(true);
		final String token = UUID.randomUUID().toString();
		final Object mutex = WebUtils.getSessionMutex(session);
		synchronized (mutex) {
			session.setAttribute(Globals.TRANSACTION_TOKEN_KEY, token);
		}
		return true;
	}

	/**
	 * Check the given Transaction token in request is valid or not
	 * 
	 * @param httpRequest the current request
	 * @return
	 */
	public static boolean isTokenValid(final HttpServletRequest httpRequest) {
		return isTokenValid(httpRequest, false);
	}

	/**
	 * Check the given Transaction token in request is valid and Transaction Token
	 * from current HttpSession
	 * 
	 * @param httpRequest the current request
	 * @param reset       reset flag
	 * @return
	 */
	public static boolean isTokenValid(final HttpServletRequest httpRequest, final boolean reset) {
		// Retrieve the current session for this request
		final HttpSession session = httpRequest.getSession(false);
		if (Objects.isNull(session)) {
			return false;
		}
		String saved = null;
		// Retrieve the transaction token from this session, and
		// reset it if requested
		final Object mutex = WebUtils.getSessionMutex(session);
		synchronized (mutex) {
			saved = (String) session.getAttribute(Globals.TRANSACTION_TOKEN_KEY);
		}
		if (Objects.isNull(saved)) {
			return false;
		}
		if (reset) {
			resetToken(httpRequest);
		}
		// Retrieve the transaction token included in this request
		final String token = httpRequest.getParameter(Globals.TRANSACTION_TOKEN_KEY);
		if (Objects.isNull(token)) {
			return false;
		}
		return saved.equals(token);
	}

	/**
	 * Remove Transaction Token from current HttpSession
	 * 
	 * @param httpRequest current HttpServletRequest
	 */
	public static void resetToken(final HttpServletRequest httpRequest) {
		final HttpSession session = httpRequest.getSession(false);
		if (Objects.isNull(session)) {
			return;
		}
		final Object mutex = WebUtils.getSessionMutex(session);
		synchronized (mutex) {
			session.removeAttribute(Globals.TRANSACTION_TOKEN_KEY);
		}
	}

	/**
	 * Check current request is generated by hitting cancel button.
	 * 
	 * @param httpRequest current HttpServletRequest
	 * @return
	 */
	public static boolean isCancelled(final HttpServletRequest httpRequest) {
		return (Objects.nonNull(httpRequest.getParameter(Globals.CANCEL_PROPERTY))
				|| Objects.nonNull(httpRequest.getParameter(Globals.CANCEL_PROPERTY_X)));
	}

	/**
	 * Adds the {@code ActionErrors} as the request attribute under key
	 * {@link Globals#ERROR_KEY}
	 * 
	 * @param httpRequest current HttpServletRequest
	 * @param errors      ActionErrors object to save ,may be null
	 */
	public static void saveErrors(final HttpServletRequest httpRequest, @Nullable final ActionErrors errors) {
		// Remove any error messages attribute if none are required
		if ((Objects.isNull(errors)) || errors.isEmpty()) {
			httpRequest.removeAttribute(Globals.ERROR_KEY);
			return;
		} // Save the error messages We need
		httpRequest.setAttribute(Globals.ERROR_KEY, errors);
	}

	/**
	 * Adds the {@code ActionMessages} as the request attribute under key
	 * {@link Globals#MESSAGE_KEY}
	 * 
	 * @param httpRequest current HttpServletRequest
	 * @param messages
	 */
	public static void saveMessages(final HttpServletRequest httpRequest, @Nullable final ActionMessages messages) {
		// Remove any messages attribute if none are required
		if ((Objects.isNull(messages)) || messages.isEmpty()) {
			httpRequest.removeAttribute(Globals.MESSAGE_KEY);
			return;
		}
		// Save the messages We need
		httpRequest.setAttribute(Globals.MESSAGE_KEY, messages);
	}

	/**
	 * Adds the {@code ActionMessages} as the session attribute under key
	 * {@link Globals#MESSAGE_KEY}
	 * 
	 * @param session  current HttpSession
	 * @param messages
	 */
	public static void saveMessages(final HttpSession session, @Nullable final ActionMessages messages) {
		// Remove any messages attribute if none are required
		if ((Objects.isNull(messages)) || messages.isEmpty()) {
			session.removeAttribute(Globals.MESSAGE_KEY);
			return;
		}
		// Save the messages we need
		session.setAttribute(Globals.MESSAGE_KEY, messages);
	}

	/**
	 * Adds the {@code ActionErrors} as the request attribute under key
	 * {@link Globals#ERROR_KEY}
	 * 
	 * @param session current HttpSession
	 * @param errors  ActionErrors object to save ,may be null
	 */
	public static void saveErrors(final HttpSession session, @Nullable final ActionErrors errors) {
		// Remove the error attribute if none are required
		if ((Objects.isNull(errors)) || errors.isEmpty()) {
			session.removeAttribute(Globals.ERROR_KEY);
			return;
		}
		// Save the errors we need
		session.setAttribute(Globals.ERROR_KEY, errors);
	}

	/**
	 * Adds the {@code ActionMessages} as the request attribute under key
	 * {@link Globals#MESSAGE_KEY}
	 * 
	 * @param httpRequest current HttpServletRequest
	 * @param messages    ActionMessages object to save ,may be null
	 */
	public static void addMessages(final HttpServletRequest httpRequest, @Nullable final ActionMessages messages) {
		if (Objects.isNull(messages)) {
			return;
		}
		// get any existing messages from the request, or make a new one
		ActionMessages requestMessages = (ActionMessages) httpRequest.getAttribute(Globals.MESSAGE_KEY);
		if (Objects.isNull(requestMessages)) {
			requestMessages = new ActionMessages();
		}
		// add incoming messages
		requestMessages.add(messages);
		// if still empty, just remove attribute from the request
		if (requestMessages.isEmpty()) {
			httpRequest.removeAttribute(Globals.MESSAGE_KEY);
			return;
		}
		// Save the messages
		httpRequest.setAttribute(Globals.MESSAGE_KEY, requestMessages);
	}

	/**
	 * Adds the {@code ActionErrors} as the request attribute under key
	 * {@link Globals#ERROR_KEY}
	 * 
	 * @param httpRequest current HttpServletRequest
	 * @param messages    ActionErrors object to save ,may be null
	 */
	public static void addErrors(final HttpServletRequest httpRequest, @Nullable final ActionErrors errors) {
		if (Objects.isNull(errors)) {
			return;
		}
		// get any existing errors from the request, or make a new one
		ActionErrors requestErrors = (ActionErrors) httpRequest.getAttribute(Globals.ERROR_KEY);
		if (Objects.isNull(requestErrors)) {
			requestErrors = new ActionErrors();
		}
		// add incoming errors
		requestErrors.add(errors);
		// if still empty, just remove attribute from the request
		if (requestErrors.isEmpty()) {
			httpRequest.removeAttribute(Globals.ERROR_KEY);
			return;
		}
		// Save the errors
		httpRequest.setAttribute(Globals.ERROR_KEY, requestErrors);
	}

	/**
	 * Retrieve or create {@code ActionErrors} as the request First lookup attribute
	 * under key {@link Globals#ERROR_KEY} ,If {@code null} create new
	 * 
	 * @param httpRequest current HttpServletRequest
	 * @return
	 */
	public static ActionErrors getErrors(final HttpServletRequest httpRequest) {
		ActionErrors errors = (ActionErrors) httpRequest.getAttribute(Globals.ERROR_KEY);
		if (Objects.isNull(errors)) {
			errors = new ActionErrors();
		}
		return errors;
	}

	/**
	 * Check whether current {@code HttpServletRequest} contains any ActionErrors or
	 * Not.
	 * 
	 * @param httpRequest
	 * @return
	 */
	public static boolean hasErrors(final HttpServletRequest httpRequest) {
		final ActionErrors errors = (ActionErrors) httpRequest.getAttribute(Globals.ERROR_KEY);
		boolean hasErrors = false;
		if (Objects.nonNull(errors) && !errors.isEmpty()) {
			hasErrors = true;
		}
		return hasErrors;
	}

	public static boolean isEmpty(final String[] array) {
		return Objects.isNull(array) || array.length == 0;
	}

	public static ActionMessages getMessages(final HttpServletRequest httpRequest) {
		ActionMessages messages = (ActionMessages) httpRequest.getAttribute(Globals.MESSAGE_KEY);
		if (Objects.isNull(messages)) {
			messages = new ActionMessages();
		}
		return messages;
	}

	/**
	 * 
	 * Change the user Locale to new Value
	 * 
	 * @param httpRequest The current HttpServletRequest request we are processing
	 * @param locale      new Locale
	 * @return {@code true} if operation is successful.
	 */
	public static boolean setLocale(final HttpServletRequest httpRequest, @Nullable final Locale locale) {
		Locale newLocale = locale;
		if (Objects.isNull(newLocale)) {
			newLocale = Locale.getDefault();
		}
		final LocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(httpRequest);
		if (Objects.isNull(localeResolver)) {
			throw new ConfigurationException(
					"LocaleResolver bean not found,Have you configured this bean in Spring ApplicationContext?");
		}
		localeResolver.setLocale(httpRequest, getResponse(), newLocale);
		return true;
	}

	/**
	 * Encodes the specified URL by including the session ID to it based on the
	 * configured Session tracking mode.
	 * 
	 * @param url URL to be encoded
	 * @return
	 */
	public static String encodeURL(final String url) {
		return encodeURL(url, false);
	}

	/**
	 * Encodes the specified URL by including the session ID to it based on the
	 * configured Session tracking mode.
	 * 
	 * @param url
	 * @param redirect
	 * @return
	 */
	public static String encodeURL(final String url, final boolean redirect) {
		final ServletRequestAttributes servletReqAttrs = getServletRequestAttributes();
		if (Objects.nonNull(servletReqAttrs)) {
			return encodeURL(url, redirect, servletReqAttrs.getRequest(), servletReqAttrs.getResponse());
		}
		return url;
	}

	/**
	 * Encodes the specified URL by including the session ID
	 * 
	 * @param url
	 * @param redirect
	 * @param httpRequest
	 * @param httpResponse
	 * @return
	 */
	public static String encodeURL(final String url, final boolean redirect, final HttpServletRequest httpRequest,
			final HttpServletResponse httpResponse) {
		/*
		 * httpResponse will be null if request is not flowing through Spring MVC
		 * infrastructure .E.g. UrlTag in JSP directly calling processUrl. eg index.jsp
		 * using Spring UrlTag
		 */
		if (Objects.nonNull(httpResponse) && !httpRequest.isRequestedSessionIdFromCookie()) {
			// Session exists and Not using cookie based Http Session Tracking
			if (redirect) {
				return httpResponse.encodeRedirectURL(url);
			} else {
				return httpResponse.encodeURL(url);
			}
		}

		return url;
	}

	/**
	 * Return the RequestAttributes bound to the current Web container Thread.
	 * 
	 * @return
	 */
	public static ServletRequestAttributes getServletRequestAttributes() {
		ServletRequestAttributes servletReqAttrs = null;
		final RequestAttributes attributes = RequestContextHolder.getRequestAttributes();
		if (Objects.nonNull(attributes) && ServletRequestAttributes.class.isInstance(attributes)) {
			servletReqAttrs = ServletRequestAttributes.class.cast(attributes);
		}
		return servletReqAttrs;
	}

	/**
	 * Utility method to get current HttpServletRequest
	 * 
	 * @return HttpServletRequest
	 */
	public static HttpServletRequest getRequest() {
		HttpServletRequest httpRequest = null;
		final ServletRequestAttributes servletReqAttrs = getServletRequestAttributes();
		if (Objects.nonNull(servletReqAttrs)) {
			httpRequest = servletReqAttrs.getRequest();
		}
		return httpRequest;
	}

	/**
	 * Utility method to get current HttpServletResponse
	 * 
	 * @return HttpServletResponse
	 */
	public static HttpServletResponse getResponse() {
		HttpServletResponse httpResponse = null;
		final ServletRequestAttributes servletReqAttrs = getServletRequestAttributes();
		if (Objects.nonNull(servletReqAttrs)) {
			httpResponse = servletReqAttrs.getResponse();
		}
		return httpResponse;
	}

	/**
	 * Utility method to get current Locale
	 * 
	 * @return returns Users current Locale
	 */
	public static Locale getLocale() {
		return LocaleContextHolder.getLocale();
	}

	/**
	 * Utility method to get current {@code ActionContext}
	 * 
	 * @return ActionContext
	 */
	public static ActionContext getActionContext() {
		final HttpServletRequest httpRequest = getRequest();
		return getActionContext(httpRequest);
	}

	public static ActionContext getActionContext(final HttpServletRequest httpRequest) {
		Objects.requireNonNull(httpRequest, Globals.HTTP_SERVLET_REQUEST_CANNOT_BE_NULL);
		return ActionContext.class.cast(httpRequest.getAttribute(Globals.ACTION_CONTEXT_KEY));
	}

	/**
	 * Find all {@code ActionMapping} in given {@code ApplicationContext}
	 * 
	 * @param applicationContext
	 * @return
	 */
	public static Collection<ActionMapping> findActionMappings(final ApplicationContext applicationContext) {
		Objects.requireNonNull(applicationContext, Globals.APPLICATION_CONTEXT_CANNOT_BE_NULL);
		final Map<String, ActionMapping> actionMappingBeans = applicationContext.getBeansOfType(ActionMapping.class);
		if (!actionMappingBeans.isEmpty()) {
			return actionMappingBeans.values();
		}
		return Collections.emptyList();
	}

	/**
	 * Check the {@code HttpServletRequest} is initiated from browser or
	 * internal(forward/include) flows.
	 * 
	 * @param httpRequest
	 * @return
	 */
	public static boolean isExternalRequest(final HttpServletRequest httpRequest) {
		Objects.requireNonNull(httpRequest, Globals.HTTP_SERVLET_REQUEST_CANNOT_BE_NULL);
		return DispatcherType.REQUEST.equals(httpRequest.getDispatcherType());
	}

	/**
	 * Utility method to retrieve or generate Exception GUID/UUID and save it in
	 * request scope for future reference. Show exception guid in UI using
	 * 
	 * <pre class="code">
	 *  ${springbridge_exception_guid}
	 * </pre>
	 * 
	 * Developers can easily locate the error in application logs from generic
	 * error-page screenshots if you include Exception GUID details in application
	 * error-pages.
	 * 
	 * @param httpRequest
	 * @param exc
	 * @return returns existing guid or newly generated GUID
	 */
	public static String getOrComputeExceptionGUIDIfAbsent(final HttpServletRequest httpRequest, final Exception exc) {
		Objects.requireNonNull(httpRequest, Globals.HTTP_SERVLET_REQUEST_CANNOT_BE_NULL);
		Objects.requireNonNull(exc, Globals.EXCEPTION_CANNOT_BE_NULL);
		if (Objects.nonNull(httpRequest.getAttribute(Globals.SPRINGBRIDGE_EXCEPTION_GUID))) {
			return String.valueOf(httpRequest.getAttribute(Globals.SPRINGBRIDGE_EXCEPTION_GUID));
		}
		final String guid = UUID.randomUUID().toString();
		httpRequest.setAttribute(Globals.SPRINGBRIDGE_EXCEPTION_GUID, guid);
		return guid;
	}

	/**
	 * Generate value by replacing place holders like /jsp/Wildcard/{1}.jsp.
	 * <b>Note:-</b> This method only supports placeholders from 0 to 9.
	 * 
	 * @param pattern
	 * @param matchedPatterns
	 * @return path after replacing place holders
	 */
	public static String generateMatchingValue(final String pattern, final Map<String, String> matchedPatterns) {
		if (Objects.isNull(pattern) || !isMessageFormatPattern(pattern)) {
			return pattern;
		}
		final int len = pattern.length();
		final StringBuilder sbValue = new StringBuilder(128);
		char c;
		String placeholderValue;
		int i = 0;
		while (i < len) {
			c = pattern.charAt(i);
			if (i < len - 2 && c == '{' && '}' == pattern.charAt(i + 2)) {
				placeholderValue = matchedPatterns.get(String.valueOf(pattern.charAt(i + 1)));
				if (Objects.nonNull(placeholderValue)) {
					sbValue.append(placeholderValue);
				}
				i += 2;
			} else {
				sbValue.append(c);
				i++;
			}
		}
		return sbValue.toString();
	}

	/**
	 * Check given value is a pattern or not
	 * 
	 * @param strVal
	 * @return
	 */
	public static boolean isMessageFormatPattern(final String strVal) {
		if (StringUtils.hasText(strVal)) {
			return Globals.MESSAGE_FORMAT_PATTERN.matcher(strVal).matches();
		}
		return false;
	}

	/**
	 * Convert the given Virtual web application resource path to real-path (Valid
	 * request URI) based on current execution context.
	 * 
	 * @param httpRequest
	 * @param pattern
	 * @return
	 */
	public static String formatValue(final HttpServletRequest httpRequest, final String pattern) {
		String resolvedValue = pattern;
		@SuppressWarnings("unchecked")
		final Map<String, String> matchedPatterns = (Map<String, String>) httpRequest
				.getAttribute(Globals.MATCHED_PATTERNS_MAP);
		if (Objects.nonNull(matchedPatterns) && isMessageFormatPattern(resolvedValue)) {
			resolvedValue = generateMatchingValue(resolvedValue, matchedPatterns);
		}
		return resolvedValue;
	}

}
